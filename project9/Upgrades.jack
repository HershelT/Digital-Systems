class Upgrades {
    field LongNum costOfUpgrade;
    field LongNumbers numbers;

    field int worthOfUpgrade;
    field int multiplier;
    field LongNum count;
    field LongNum cps;
    field LongNum currentCPS;

    // Initialize with set cost given to Upgrades
    constructor Upgrades new(LongNum cost, LongNum amount, LongNum cookiesPerSecond) {
        // Set up costToUpgrade and number of that upgrade as LongNum
        let costOfUpgrade = LongNum.new(); // Cost of upgrade
        do costOfUpgrade.addLong(cost);
        let numbers = LongNumbers.new(); // Initialize numbers
        // define the amount of upgrades (count)
        let count = LongNum.new(); // Number of upgrades
        do count.addLong(amount); // Number of upgrades
        // Define the cookies per second (cps) variable
        let cps = LongNum.new(); // Cookies per second
        do cps.addLong(cookiesPerSecond); // Cookies per second
        // set up cookies per second as a longNum
        let currentCPS = LongNum.new(); // Current cookies per second (cps * count)
        do currentCPS.addLong(cps); // Current cookies per second
        do currentCPS.multiplyLong(amount); // Current cookies per second
        return this;
    }

    method LongNum getCost() {
        return costOfUpgrade;
    }

    method LongNum getAmount() {
        return count;
    }

    method LongNum getCPS() {
        return currentCPS;
    }

    // Upgrade by changing price and amount of upgrade
    method void getUpgrade() {
        // Logic that does not get int overflow
        // var int divide;
        var LongNum tempMulti;
        var LongNum tempParentesis;
        var LongNum tempCost;
        // var LongNum tempAmount;

        // let tempAmount = LongNum.new();
        let tempMulti = LongNum.new();
        let tempParentesis = LongNum.new();
        let tempCost = LongNum.new();

        // Do MATH To Calculate new CostOfUpgrade:
        // costOfUpgrade = costOfUpgrade + (((costOfUpgrade / 100) + 1) * (multiplier - 100));
        do tempCost.addLong(costOfUpgrade);
        // do division without divideLong call
        // while (tempCost.greaterThanLong(numbers.getOneHundred())) {
        //     do tempCost.subtractLong(numbers.getOneHundred());
        //     let divide = divide + 1;
        // }
        // let tempCost = numbers.getZero();
        // do tempCost.add(divide);


        do tempCost.divideLong(numbers.getOneHundred());
        do tempParentesis.addLong(numbers.getOne());
        do tempParentesis.addLong(tempCost);
        do Memory.deAlloc(tempCost);

        do tempMulti.addLong(numbers.getFifteen());

        // while (tempAmount.lessThanLong(tempMulti)) {
        //     do tempAmount.addLong(numbers.getOne());
        //     do tempParentesis.addLong(tempCost);
        // }

        do tempParentesis.multiplyLong(tempMulti);
        do Memory.deAlloc(tempMulti);

        do costOfUpgrade.addLong(tempParentesis);
        do Memory.deAlloc(tempParentesis);


        // Update count by adding one
        do count.addLong(numbers.getOne());
        // Add a cps everytime Upgrade is called (thus currentCPS = cps*count)
        do currentCPS.addLong(cps);

        // Free memory
        // do Memory.deAlloc(divide);
        // do Memory.deAlloc(tempAmount);


        return;
    }
}